Registering and Logging In

	To register a new user, we use register(), where there is a GET and POST method. POST requests data, such as username, password, and confirmation. Moreover, we used logic to give conditions when creating a password and username and if the conditions failed, our helper function, apology(), outputs an error message. Moreover, when the username and password satisfy our conditions, we insert the username and the password’s hash into our users data. We hash the password through generate_password_hash from the werkzeug package. We also decided to redirect the user to the login page afterwards. In GET, the register.html is returned.

	In the login(), we first clear any user_id through session.clear(). There is also a POST and GET method, where in POST the user’s username and password is checked for validity through logic using request.form.get(). Furthermore, we use session[“user_id”] = rows[0][“id] (where rows is a SQL query from users for a particular username) in order to remember which user has logged in. The user is then redirected to the index, which has a greeting message in its html. Via Get, the site just returns the login.html. Additionally, to log out, one can click on the logout button, which clears any user_id through session.clear() and redirects to the login form.

Creating and Joining Leagues

	To create (create()) or join (join()) a league, the user is first prompted to either create or join a league via the leagues.html. We decided to do this as we felt it was more organized this way than creating another tab for joining a league. If a user chooses to create a league, the user is then routed to create, where there is also a POST and GET method. In POST, the user’s league name and number of teams in the league has to fulfill the conditions we laid out using request.form.get() and logic. We also used a for loop to iterate through each league name to make sure a league name was submitted and alphabetic. Moreover, once the league information satisfies our conditions, the league is then inserted into our leagues database where the league name and number of teams that can join is inserted. The user is then redirected to a message that the league was created via created.html.

	Joining a league has both a POST and GET. In POST, we have a drop-down where users can choose which league to join via request.form.get(“symbol”). Moreover, we query for league id’s via l_id = db.execute("""SELECT * FROM leagues WHERE league_name = ?""", request.form.get("symbol")) where l_id[0][“id”] represents the league id based on the league we selected from the drop-down. We then insert data about the user that joined the league into our league_user table which keeps track of users and the leagues they are in. This is done through         db.execute("INSERT INTO league_user (league_id, user_id, league_name) VALUES (?,?,?)", l_id[0]["id"], pID, request.form.get("symbol")). Furthermore, to show the number of teams that are currently in a league, we decided to do db.execute("UPDATE leagues SET league_current = league_current + 1 WHERE league_name = ?", request.form.get("symbol")). This will make it easier for users to know available leagues to join via the join.html, which shows leagues where the current number of teams is less than the maximum number of teams that can join. This is also evident in the GET method of join.

Adding Players

	Before adding and dropping players, we have created leagueselect() functions in order to pick which league a user wants to play around with. We did this because then the user can not only join different leagues but also view relevant information to the particular league. leagueselect() allows us to have session league id’s, which we will thus need. leageueselect() is used for “My Team,” “Players,” and “Leaderboards” tabs.

	First, we created the helper function, player_stats(), which called the API from balldontlio.io. Through contacting the API, we were able to extract player id and insert them to our database, players. Moreover, the API had season averages and so we were also able to import their season averages for particular statistical categories into our stats database as well. Once we were able to make our stats database, we then made the function, players() in our application.py. We set made stats an empty dict and then made stats = db.execute("SELECT * FROM stats WHERE player_id NOT IN (SELECT player_id from user_player WHERE league_id = ?)", int(session['league_id'])) in order for users to choose players that are only available in the league they choose to look at in players.html. Moreover, the players() function had a post method, so users can sort the players on the table by salary or points per game. We also showed the user’s cash in that league by querying for the user’s cash in that league.

	Moreover, we created the add() function, which we used a form for our players.html. The add function simply queried for the cost of a player and checked to see if the player can afford that player through basic logic. We also checked to make sure that the maximum number of players in a team is 7. Moreover, based on the players added by clicking on the Add button, the form for each row will have the value of the player id, which will be retrieved for whichever row the user picks. The players would be inserted into the database, user_player, which keeps track of the players a user has. We also updated the cash of the user in his respective league in league_user through SQL. Once a user selects players to add, he is then routed to myteam, which shows his roster.

My Team and Dropping

	In update(), we made a fantasy_points database and used update() to import fantasy points and relevant statistics in that table. Our update() function used the helper function, lookup(), which looked up stats of the nba players for games from the API and imported them into the fantasy_points database. Moreover, we were able to convert statistics into fantasy points using the formula we added to lookup(). The formula is Fantasy Points = Points + 2*Assists + 2*Rebounds + 2*Steals + 2*Blocks - 2*Turnover. Total_points also represent the fantasy points of a player in the fantasy_points database. With update(), we were able to update players’ names and position into the database, fantasy_points. We used a for loop to iterate through each player and had to use two UPDATE sql queries for name and position as it did not work for one query doing both. This was used so that we can update the fantasy_points database throughout the season by clicking on the update button. But since the NBA isn’t playing right now, we used data focusing on December of last year.
	Now that we were able to update our fantasy_points database, we made the function myteam(), which shows the fantasy points for a given team’s roster. We thus decided to make points an empty dict, which represents the fantasy points of each player in a given team. We then kept track of fantasy points for players, which was similar to what we did in tournament.py in Lab 6 by querying for distinct game id, name, and player id and position from the fantasy_points database joined with the user_player database. We selected distinct attributes to avoid overcounting. myteam query groups by player_id so that we have the fantasy points attributed to a given player while point query doesn’t group by player_id so we can find a team’s total number of fantasy points. We also iterated through point (which equals to a SQL query) so that we can show a player’s respective fantasy points in the myteam.html and populate a team’s total fantasy points. The total can also be seen when we do: total = sum(points.values()). We then update fantasy_points in the database, league_user, so that the user has the correct fantasy points in his given league.

Leaderboards

	The leaderboards.html shows the standings of a selected league. Essentially, we query for  fantasy points in a particular league by joining the fantasy_points database and league_user database and order by fantasy points. This would thus give us the particular rankings in a given league, which we simply applied to the leaderboards.html. We decided to get rankings through joining as this was quite simple to do since league_user kept track of user’s total fantasy points in a particular league.

CSS
	For CSS, we added some colors and attributes to make the site more aesthetically pleasing.

Databases
	We decided to make our databases like the way they are as they allowed us to make users join different leagues and keep track of important information for different leagues and the users that are in them. The design of the databases also made it easier to join different databases and update them accordingly.
